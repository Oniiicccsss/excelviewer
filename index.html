<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Excel Data Preview by Onyx</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"
    />
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial,
          sans-serif;
      }

      .drag-drop-area {
        border: 2px dashed #ccc;
        border-radius: 10px;
        padding: 40px;
        text-align: center;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .drag-drop-area:hover {
        background-color: #f8f9fa;
      }

      .drag-drop-area.dragover {
        background-color: #e9ecef;
        border-color: #007bff;
      }

      .card-header-custom {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      #sheetTabs {
        flex-wrap: nowrap;
        overflow-x: auto;
      }

      #previewTable {
	      table-layout: auto; /* Allows the table to size columns automatically */
	      width: 100%;
	      max-width: 100%; /* Ensures the table doesn't exceed its container */
	      border-collapse: collapse;
	  }
	  
	  #previewTable td {
	      white-space: normal; /* This is the key for enabling word wrap */
	      padding: 6px 10px;
	      word-wrap: break-word; /* Prevents long words from overflowing */
	      max-width: 250px; /* Adjust this value as needed to limit cell width */
	  }
    </style>
  </head>
  <body class="bg-light p-4">
    <div class="container">
      <h2 class="mb-4 text-center">Upload & Preview Data Excel File</h2>

      <div class="card p-4 mb-4 shadow-sm">
        <h5 class="card-title">Upload Excel/CSV File</h5>
        <div class="drag-drop-area" id="drop-zone">
          <p class="mb-0 text-muted">
            Drag & drop your file here, or click to browse.
          </p>
          <input
            id="fileInput"
            type="file"
            accept=".xlsx,.xls,.csv"
            class="d-none"
          />
        </div>
        <small class="text-muted mt-2 text-center" id="file-info-text"
          >Supported formats: .xlsx, .xls, .csv</small
        >
        <div class="mt-3" id="feedback-message"></div>
      </div>

      <div class="card shadow-sm">
        <div class="card-header card-header-custom">
          <h5 class="mb-0">Data Preview</h5>
          <small class="text-muted" id="preview-file-name"></small>
        </div>
        <div class="card-body">
          <ul
            class="nav nav-tabs mb-3 d-none"
            id="sheetTabs"
            role="tablist"
          ></ul>
          <input
            type="text"
            id="searchInput"
            class="form-control mb-3 d-none"
            placeholder="Search in table..."
          />
          <div id="loading-spinner" class="text-center d-none">
            <div class="spinner-border text-primary" role="status">
              <span class="sr-only">Loading...</span>
            </div>
            <p class="mt-2 text-muted">Parsing file...</p>
          </div>
          <div class="table-responsive d-none" id="preview-container">
            <table
              id="previewTable"
              class="table table-bordered table-striped"
              style="width: 100%"
            >
              <thead></thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <script>
      let workbook = null;

      // DOM Element References
      const dropZone = document.getElementById("drop-zone");
      const fileInput = document.getElementById("fileInput");
      const loadingSpinner = document.getElementById("loading-spinner");
      const previewContainer = document.getElementById("preview-container");
      const feedbackMessage = document.getElementById("feedback-message");
      const previewFileName = document.getElementById("preview-file-name");
      const sheetTabs = document.getElementById("sheetTabs");
      const searchInput = document.getElementById("searchInput");
      const tbody = document.querySelector("#previewTable tbody");
      const thead = document.querySelector("#previewTable thead");

      // Event Listeners
      ["dragenter", "dragover", "dragleave", "drop"].forEach((ev) =>
        dropZone.addEventListener(ev, (e) => {
          e.preventDefault();
          e.stopPropagation();
        })
      );
      ["dragenter", "dragover"].forEach((ev) =>
        dropZone.addEventListener(ev, () => dropZone.classList.add("dragover"))
      );
      ["dragleave", "drop"].forEach((ev) =>
        dropZone.addEventListener(ev, () => dropZone.classList.remove("dragover"))
      );

      dropZone.addEventListener("drop", (e) => handleFiles(e.dataTransfer.files));
      dropZone.addEventListener("click", () => fileInput.click());
      fileInput.addEventListener("change", (e) => handleFiles(e.target.files));
      searchInput.onkeyup = () => filterTable();

      // Core Functions
      async function handleFiles(files) {
        const file = files[0];
        if (!file) return;

        if (!/\.(xlsx|xls|csv)$/i.test(file.name)) {
          showFeedback("Please upload an Excel or CSV file.", "danger");
          return;
        }

        showLoading();
        try {
          const data = await file.arrayBuffer();
          workbook = XLSX.read(data, {
            type: "array",
            cellDates: true,
            cellNF: true,
            cellText: false,
          });

          if (workbook.SheetNames.length > 0) {
            renderSheetTabs(workbook.SheetNames, file.name);
            renderTable(
              workbook.Sheets[workbook.SheetNames[0]],
              workbook.SheetNames[0],
              file.name
            );
            showFeedback(
              "File parsed successfully. Select a sheet to view.",
              "success"
            );
          } else {
            showFeedback("The uploaded file is empty.", "warning");
            hidePreview();
          }
        } catch (err) {
          console.error(err);
          showFeedback("Error parsing the file.", "danger");
          hidePreview();
        } finally {
          hideLoading();
        }
      }

      function renderSheetTabs(sheetNames, fileName) {
        sheetTabs.innerHTML = "";
        sheetTabs.classList.remove("d-none");

        sheetNames.forEach((sheetName, idx) => {
          const li = document.createElement("li");
          li.className = "nav-item";

          const a = document.createElement("a");
          a.className = "nav-link" + (idx === 0 ? " active" : "");
          a.href = "#";
          a.textContent = sheetName;
          a.onclick = (e) => {
            e.preventDefault();
            document
              .querySelectorAll("#sheetTabs .nav-link")
              .forEach((el) => el.classList.remove("active"));
            a.classList.add("active");
            renderTable(
              workbook.Sheets[sheetName],
              sheetName,
              fileName
            );
          };

          li.appendChild(a);
          sheetTabs.appendChild(li);
        });
      }

      function renderTable(sheet, sheetName, fileName) {
        const range = XLSX.utils.decode_range(sheet["!ref"]);
        const merges = sheet["!merges"] || [];
        const mergeMap = {};

        merges.forEach((m) => {
          for (let r = m.s.r; r <= m.e.r; r++) {
            for (let c = m.s.c; c <= m.e.c; c++) {
              const key = `${r}:${c}`;
              mergeMap[key] = { master: r === m.s.r && c === m.s.c, range: m };
            }
          }
        });

        thead.innerHTML = "";
        tbody.innerHTML = "";

        const headerRow = document.createElement("tr");
        headerRow.id = "table-header-row";
        for (let C = range.s.c; C <= range.e.c; ++C) {
          const cellAddress = XLSX.utils.encode_cell({ r: range.s.r, c: C });
          let cell = sheet[cellAddress];
          const td = document.createElement("td");
          td.textContent = cell ? formatCell(cell) : "";
          td.style.fontWeight = "bold";
          applyCellStyle(td, cell);
          headerRow.appendChild(td);
        }
        tbody.appendChild(headerRow);

        for (let R = range.s.r + 1; R <= range.e.r; ++R) {
          const tr = document.createElement("tr");
          for (let C = range.s.c; C <= range.e.c; ++C) {
            const key = `${R}:${C}`;
            const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
            let cell = sheet[cellAddress];
            if (mergeMap[key] && !mergeMap[key].master) {
              continue;
            }
            const td = document.createElement("td");
            if (cell) {
              td.textContent = formatCell(cell);
              applyCellStyle(td, cell);
            }
            if (mergeMap[key]) {
              const m = mergeMap[key].range;
              const rowspan = m.e.r - m.s.r + 1;
              const colspan = m.e.c - m.s.c + 1;
              if (rowspan > 1) td.rowSpan = rowspan;
              if (colspan > 1) td.colSpan = colspan;
            }
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }

        // Keep this to apply widths, but they won't force no-wrap
        if (sheet['!cols']) {
          const style = document.createElement('style');
          let colStyles = '';
          sheet['!cols'].forEach((col, index) => {
            if (col.wpx) {
              colStyles += `#previewTable th:nth-child(${index + 1}), #previewTable td:nth-child(${index + 1}) { width: ${col.wpx}px; }`;
            }
          });
          style.innerHTML = colStyles;
          document.head.appendChild(style);
        }

        previewFileName.textContent = `File: ${fileName} - Sheet: ${sheetName}`;
        previewContainer.classList.remove("d-none");
        searchInput.classList.remove("d-none");
        searchInput.value = "";
      }

      function formatCell(cell) {
        if (!cell) return "";
        if (cell.t === "d" && cell.v instanceof Date) {
          const d = cell.v;
          if (d.getFullYear() <= 1900) return d.toLocaleTimeString();
          if (d.getHours() === 0 && d.getMinutes() === 0 && d.getSeconds() === 0)
            return d.toLocaleDateString();
          return d.toLocaleString();
        }
        if (cell.t === "n") {
          if (cell.z && /[ymdhs]/i.test(cell.z)) {
            const dateObj = XLSX.SSF.parse_date_code(cell.v);
            if (dateObj) {
              const jsDate = new Date(
                Date.UTC(
                  dateObj.y || 1900,
                  (dateObj.m || 1) - 1,
                  dateObj.d || 1,
                  dateObj.H,
                  dateObj.M,
                  dateObj.S
                )
              );
              if (!dateObj.y && !dateObj.m && !dateObj.d)
                return jsDate.toLocaleTimeString();
              if (dateObj.H === 0 && dateObj.M === 0 && dateObj.S === 0)
                return jsDate.toLocaleDateString();
              return jsDate.toLocaleString();
            }
          }
          return Number(cell.v).toFixed(2);
        }
        return cell.w || cell.v || "";
      }

      function applyCellStyle(td, cell) {
        if (!cell || !cell.s) return;
        if (cell.s.font) {
          if (cell.s.font.color && cell.s.font.color.rgb) {
            td.style.color = "#" + cell.s.font.color.rgb.slice(-6);
          }
          if (cell.s.font.bold) td.style.fontWeight = "bold";
          if (cell.s.font.italic) td.style.fontStyle = "italic";
        }
        if (cell.s.fill && cell.s.fill.fgColor && cell.s.fill.fgColor.rgb) {
          td.style.backgroundColor = "#" + cell.s.fill.fgColor.rgb.slice(-6);
        }
        if (cell.s.border) {
          const borders = cell.s.border;
          if (borders.left && borders.left.style) td.style.borderLeftStyle = borders.left.style;
          if (borders.right && borders.right.style) td.style.borderRightStyle = borders.right.style;
          if (borders.top && borders.top.style) td.style.borderTopStyle = borders.top.style;
          if (borders.bottom && borders.bottom.style) td.style.borderBottomStyle = borders.bottom.style;
        }
      }

      function filterTable() {
        const filter = searchInput.value.toLowerCase();
        const tbody = document.querySelector("#previewTable tbody");
        const rows = Array.from(tbody.rows);

        let foundCount = 0;
        rows.forEach((tr) => {
          const isVisible = [...tr.cells].some((td) =>
            td.textContent.toLowerCase().includes(filter)
          );
          tr.style.display = isVisible ? "" : "none";
          if (isVisible) {
            foundCount++;
          }
        });

        const headerRow = document.getElementById("table-header-row");
        const noResultsRow = document.getElementById('no-results-row');

        if (foundCount === 0 && filter !== "") {
          if (!noResultsRow) {
            const tr = document.createElement("tr");
            tr.id = 'no-results-row';
            const td = document.createElement("td");
            td.colSpan = tbody.rows[0].cells.length;
            td.textContent = "No results found.";
            td.className = "text-center text-muted";
            tr.appendChild(td);
            tbody.appendChild(tr);
          } else {
            noResultsRow.style.display = "";
          }
        } else {
          if (noResultsRow) {
            noResultsRow.style.display = "none";
          }
        }
      }

      function sortTable(colIndex) {
        const tbody = document.querySelector("#previewTable tbody");
        const rows = Array.from(tbody.rows).slice(1);
        const headerRow = document.getElementById("table-header-row");
        const asc = !tbody.dataset.sortAsc || tbody.dataset.sortCol != colIndex;

        rows.sort((a, b) =>
          a.cells[colIndex].textContent.localeCompare(
            b.cells[colIndex].textContent,
            undefined,
            { numeric: true }
          )
        );

        if (!asc) rows.reverse();

        tbody.innerHTML = "";
        tbody.appendChild(headerRow);
        rows.forEach((r) => tbody.appendChild(r));
        tbody.dataset.sortAsc = asc;
        tbody.dataset.sortCol = colIndex;
      }

      function showLoading() {
        loadingSpinner.classList.remove("d-none");
      }

      function hideLoading() {
        loadingSpinner.classList.add("d-none");
      }

      function hidePreview() {
        previewContainer.classList.add("d-none");
        sheetTabs.classList.add("d-none");
        previewFileName.textContent = "";
        searchInput.classList.add("d-none");
      }

      function showFeedback(msg, type) {
        feedbackMessage.innerHTML = `<div class="alert alert-${type} mb-0">${msg}</div>`;
      }
    </script>
  </body>
</html>
